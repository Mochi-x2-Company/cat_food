//====================================================================
//  C言語 中級プログラミング  例題
//  高速整列算法  関数ライブラリ
//--------------------------------------------------------------------
//  AlgoSort AlgoSortProc.c
//  ソース本体
//  Linux  GCC 4.4
//--------------------------------------------------------------------
//  富永研究室  tominaga 富永浩之
//  2015.10.27
//====================================================================


/*====================================================================
//  仕様
//====================================================================

5種類の高速整列算法を実装する。
ポインタ引数で、比較回数と交換回数をカウントする。
整列過程を表示する。

シェルソート    shell_sort()  間隔を置いた事前処理の後に本処理(挿入法)
コームソート    comb_sort()   間隔を置いた事前処理の後に本処理(交換法)
マージソート    merge_sort()  再帰呼出の中で併合処理(挿入法の改良)
クイックソート  quick_sort()  振分処理の後で再帰呼出(交換法の改良)
ヒープソート    heap_sort()   ヒープ木の生成と取出(選択法の改良)

--------------------------------------------------------------------*/


//====================================================================
//  ヘッダ情報
//====================================================================

#include <stdio.h>
#include <stdlib.h>
#include "AlgoSortProc.h"

//====================================================================
//  シェルソート
//====================================================================

//--------------------------------------------------------------------
//  シェルソートの本体
//--------------------------------------------------------------------

void shell_sort(Data arr[], int n, int *ct_c, int *ct_s) 
{
  int cnt = 3;    // 間隔列の収縮係数
  int gap = 1;    // 間隔の最小値
  int p;

  //----  間隔列の初期値(1,4,13,40,121,‥)
  while ( gap <= (n/2) ) { 
    gap *= cnt; gap++; 
  }

  //----  シェルソートの本体
  while ( gap > 0 ) {
    gap /= cnt;    // 間隔の更新
    //----  シェルソートの各ラン(指定間隔での挿入法)
    for ( p = 0; p < gap; p++ ) { 
      shell_sort_run(arr, p, n, gap, ct_c, ct_s);
      //proc_view(arr, n, *ct_c, *ct_s);    // 整列過程の表示
    }
  }
}

//--------------------------------------------------------------------
//  シェルソートの各ラン(挿入法)
//--------------------------------------------------------------------

void shell_sort_run(Data arr[], int low, int hig, int gap, int *ct_c, int *ct_s) 
{
  int i, j;
  for ( i = low; i < hig-gap; i += gap ) {                   
    for ( j = i; j >= low; j -= gap ) {
      if ( arr_ord_ct(arr, j, j+gap, ct_c) ) { break; }
      arr_swap_ct(arr, j, j+gap, ct_s);
    }
  }
}


//====================================================================
//  コームソート
//====================================================================

void comb_sort(int arr[], int n, int *ct_c, int *ct_s) 
{
  double cnt = 1.3;    // 間隔列の収縮係数
  int gap = n;                // 間隔の最大値
  int k;
  Bool flag = FALSE;           // 交換の有無

  //----  コームソートの本体
  while ( gap > 1 || flag == TRUE ) {
    //--  
    flag = FALSE;    // 交換無に初期化
    gap /= cnt;      // 間隔の更新
    //--  間隔の調整
    if ( gap == 0 ) { gap = 1; }                  // 間隔1は必須
    if ( gap == 9 || gap == 10 ) { gap = 11; }    // 経験的な調整
    //--  コームソートの各ラン(指定間隔での単純交換法)
    for ( k = 0; k < n - gap; k++ ) {
      if ( ! arr_ord_ct(arr, k, k+gap, ct_c) ) { 
        arr_swap_ct(arr, k, k+gap, ct_s); 
        flag = TRUE;
      } 
    }
    proc_view(arr, n, *ct_c, *ct_s);    // 整列過程の表示
  }
}


//====================================================================
//  クイックソート
//====================================================================

//--------------------------------------------------------------------
//  クイックソートの本体
//--------------------------------------------------------------------

void quick_sort(Data arr[], int n, int *ct_c, int *ct_s) 
{
  //----  クイックソートの再帰処理の呼出
  quick_sort_rec(arr, 0, n-1, n, ct_c, ct_s);
}

//--------------------------------------------------------------------
//  クイックソートの再帰処理(トップダウン)
//--------------------------------------------------------------------

void quick_sort_rec(Data arr[], int low, int hig, 
                    int n, int *ct_c, int *ct_s) 
{
  int i = low;
  int j = hig;
  int k = (low+hig)/2;    // 中央位置
  Data key = arr[k];      // 基準値

  //----  部分列の範囲の表示
  //printf("[%2d %2d]\n", low, hig);

  //----  再帰終了
  if ( low  >= hig ) { return; }

  //----  振分処理
  while ( i <= j ) { 
    //----  左側での比較
    while ( arr[i] < key ) {    // 左側で基準値以上の要素
      (*ct_c)++; i++;    
    }    
    (*ct_c)++;    // 最後の比較の分
    //----  右側での比較
    while ( arr[j] > key ) {    // 右側で基準値以下の要素
      (*ct_c)++; j--;    
    }    
    (*ct_c)++;    // 最後の比較の分
    //----  交換
    if ( i > j ) { break; }          // 走査の完了
    arr_swap_ct(arr, i, j, ct_s);    // 要素の交換
    i++; j--;
  }

  //----  整列過程の表示
  //proc_view(arr, n, *ct_c, *ct_s);

  //----  再帰呼出
  if ( low < j ) { quick_sort_rec(arr, low, j, n, ct_c, ct_s); }
  if ( hig > i ) { quick_sort_rec(arr, i, hig, n, ct_c, ct_s); }
}

//--------------------------------------------------------------------
//  クイックソートの振分処理
//--------------------------------------------------------------------

void parti_proc(Data arr[], int low, int hig, int key, int *m_l, int *m_h) 
{
  int tmp;
  while ( 1 ) { 
    //----  左右からの比較による交換位置の特定
    while ( arr[low] < key ) { low++; }
    while ( arr[hig] > key ) { hig--; }
    //----  要素交換
    if ( low >= hig ) { break; }
    arr_swap(arr, low, hig);
    low++; hig--;
  }
  *m_l = low; *m_h = hig;
}

//--------------------------------------------------------------------
//  クイックソートの反復処理(スタックによる深優先処理)
//--------------------------------------------------------------------

void quick_sort_it_st(Data arr[], int n) 
{
  int m = 0;
  int *low = (int *) malloc(sizeof(int)*n);    // 部分列の左端を格納するスタック
  int *hig = (int *) malloc(sizeof(int)*n);    // 部分列の右端を格納するスタック
  int l, h;        // 部分列の両端
  int i, j, k;     // 反復変数
  Data key;        // 基準値
  Data tmp;        // 一時値

  //----  スタックの初期化
  low[m] = 0;      // 全体の左端を格納
  hig[m] = n-1;    // 全体の右端を格納
  m++;

  //----  クイックソートの本体
  while ( m > 0 ) {
    //----  部分列の両端をスタックからポップ
    m--;
    l = low[m]; i = l;
    h = hig[m]; j = h;
    k = (i+j) /2;      // 中央位置
    key = arr[k];      // 基準値
    //----  振分処理
    while ( i <= j ) {
      //----  左右からの比較による交換位置の特定
      while ( arr[i] < key ) { i++; }
      while ( arr[j] > key ) { j--; }
      //----  要素交換
      if ( i > j ) { break; }
      arr_swap(arr, i, j);
      i++; j--;
    }
    //----  部分列の両端をスタックにプッシュ
    if ( h > i ) { hig[m] = h; low[m] = i; m++; }
    if ( l < j ) { low[m] = l; hig[m] = j; m++; }
  }
}

//--------------------------------------------------------------------
//  クイックソートの反復処理(キューによる幅優先処理)
//--------------------------------------------------------------------

/*--------------------------------------------------------------------
// 演習として未実装

void quick_sort_it_qu(Data arr[], int n) 
{
  
}
--------------------------------------------------------------------*/


//====================================================================
//  マージソート
//====================================================================

//--------------------------------------------------------------------
//  マージソートの本体
//--------------------------------------------------------------------

void merge_sort(Data arr[], int n, int *ct_c, int *ct_s) 
{
  //----  事前処理
  Data *tmp = (Data *) malloc(sizeof(Data) * (n+1)/2);    // 一時配列の確保
  //----  マージソートの再帰処理の呼出
  merge_sort_rec(arr, 0, n-1, tmp, n, ct_c, ct_s);
  //----  部分列の範囲の表示
  //printf("[%2d %2d]\n", 0, n-1);
  //----  整列過程の初期状態の表示
  //proc_view(arr, n, *ct_c, *ct_s);
}

//--------------------------------------------------------------------
//  マージソートの再帰処理(ボトムアップ)
//--------------------------------------------------------------------

void merge_sort_rec(Data arr[], int low, int hig, Data tmp[], 
                    int n, int *ct_c, int *ct_s) {
  //----  局所変数
  int i = 0;
  int j = (low+hig)/2;    // 中央位置
  int k;
  //----  再帰終了
  if ( low >= hig ) { return; }
  // printf("[%2d %2d]\n", low, hig);
  //----  再帰呼出
  if ( low < j ) { 
    merge_sort_rec(arr, low, j, tmp, n, ct_c, ct_s);    // 左部分列
    //----  整列過程の表示
    //printf("[%2d %2d]\n", low, j);
    //proc_view(arr, n, *ct_c, *ct_s);
  }
  j++;
  if ( j < hig ) { 
    merge_sort_rec(arr, j, hig, tmp, n, ct_c, ct_s);    // 右部分列
    //----  整列過程の表示
    //printf("[%2d %2d]\n", j, hig);
    //proc_view(arr, n, *ct_c, *ct_s);
  }
  //----  事前処理
  for ( k = low; k < j; k++ ) { tmp[k-low] = arr[k]; }
  //----  併合処理
  for ( k = low; k < j; k++ ) {
    if ( j > hig ) { 
      arr[k] = tmp[i]; i++; (*ct_s)++;
    } else {
      (*ct_c)++;
      if ( tmp[i] <= arr[j] ) { 
        arr[k] = tmp[i]; i++; (*ct_s)++;
      } else { 
        arr[k] = arr[j]; j++; (*ct_s)++; 
      }
    }
  }
}

//--------------------------------------------------------------------
//  マージソートの反復処理(キューによる幅優先処理)
//--------------------------------------------------------------------

void merge_sort_it_qu(Data arr[], int n) 
{
  //----  局所変数
  int g = 2;    // 部分列の長さ
  int l, h;     // 左右の部分列の先頭
  //----  全体列になるまで
  while ( g < n-1 ) {
    l = 0; h = l+g-1;    // 左部分列よ右部分列の先頭
    while ( h < n ) {
      //----  併合処理の呼出
      merge_proc(arr, l, h);
      //----  左右の部分列の更新
      l += g; h = l+g-1;
    }
    //----  部分列の更新
    g *= 2;
  }
}

//--------------------------------------------------------------------
//  マージソートの併合処理
//--------------------------------------------------------------------

void merge_proc(Data arr[], int l, int h)
{
  //----  局所変数
  int i = l;
  int j = (l+h)/2;
  int k;
  Data *tmp = (Data *) malloc(sizeof(Data)*(l-h));
  //----  事前処理(左部分列の一時配列のコピー)
  for ( k = l; k < j; k++ ) { tmp[k-l] = arr[k]; }
  //----  併合処理
  for ( k = l; k < j; k++ ) {
    if ( j > h || tmp[i] <= arr[j] ) { 
      arr[k] = tmp[i]; i++;    // 左部分列からの要素コピー
    } else { 
      arr[k] = arr[j]; j++;    // 右部分列からの要素コピー
    }
  }
}

//--------------------------------------------------------------------
//  マージソートの反復処理(スタックによる深優先処理)
//--------------------------------------------------------------------

/*--------------------------------------------------------------------
// 演習として未実装

void merge_sort_it_st(Data arr[], int n) 
{
  
}
--------------------------------------------------------------------*/


//====================================================================
//  ヒープソート
//====================================================================

//--------------------------------------------------------------------
//  ヒープソートの本体
//--------------------------------------------------------------------

void heap_sort(Data arr[], int n, int *ct_c, int *ct_s) 
{
  int k;

  //----  ヒープ木への変換
  for ( k = n/2; k >= 0; k-- ) {
    heap_sort_rec(arr, k, n-1, ct_c, ct_s);    // ヒープ木の篩落し
  }
  //proc_view(arr, n, *ct_c, *ct_s);             // 整列過程の表示

  //----  ヒープ木からの整列
  for ( k = n-1; k > 0; k-- ) {  
    arr_swap_ct(arr, 0, k, ct_s);              // 最大要素を整列済の部分列に移動
    heap_sort_rec(arr, 0, k-1, ct_c, ct_s);    // ヒープ木の篩落し
    //proc_view(arr, n, *ct_c, *ct_s);           // 整列過程の表示
  }
}

//--------------------------------------------------------------------
//  ヒープ木の篩落し(再帰法)
//--------------------------------------------------------------------

void heap_sort_rec(Data arr[], int up, int lst, int *ct_c, int *ct_s) 
{
  int ch = 2*up+1;    // 左の子節の位置

  //----  再帰終了
  if ( ch > lst ) { return; }

  //----  子節同士の比較
  if ( ch+1 <= lst ) {                      // 右の子節があるとき
    (*ct_c)++;    // 比較回数のカウント
    if ( arr[ch] < arr[ch+1] ) { ch++; }    // 子節同士の比較
  }

  //----  親節と子節の比較
  (*ct_c)++;    // 比較回数のカウント
  if ( arr[up] < arr[ch] ) {                    // 親節と子節の比較
    arr_swap_ct(arr, up, ch, ct_s);             // 親節と子節の交換
    heap_sort_rec(arr, ch, lst, ct_c, ct_s);    // 子節を根節とする再帰呼出
  }
}


//====================================================================
//  補助関数
//====================================================================

//--------------------------------------------------------------------
//  配列の要素の比較
//--------------------------------------------------------------------

Bool arr_ord(Data arr[], int p1, int p2) 
{
  if ( arr[p1] <= arr[p2] ) { return TRUE; } else { return FALSE; }
}

Bool arr_ord_ct(Data arr[], int p1, int p2, int *ct) 
{
  (*ct)++;    // 比較回数のカウント
  if ( arr[p1] <= arr[p2] ) { return TRUE; } else { return FALSE; }
}

//--------------------------------------------------------------------
//  配列の要素の交換
//--------------------------------------------------------------------

void arr_swap(Data arr[], int p1, int p2) 
{
  Data tmp;
  tmp = arr[p1]; arr[p1] = arr[p2]; arr[p2] = tmp;
}

void arr_swap_ct(Data arr[], int p1, int p2, int *ct) 
{
  Data tmp;
  (*ct)++;     // 交換回数のカウント
  tmp = arr[p1]; arr[p1] = arr[p2]; arr[p2] = tmp;
}


//====================================================================
//  データの入出力
//====================================================================

//--------------------------------------------------------------------
//  配列への入力
//--------------------------------------------------------------------

void input_arr(Data arr[], int n) 
{
  int k;
  for ( k = 0; k < n; k++ ) { scanf("%d", &arr[k]); }
}

//--------------------------------------------------------------------
//  配列からの出力
//--------------------------------------------------------------------

void output_arr(Data arr[], int n) 
{
  int k;
  for ( k = 0; k < n; k++ ) { printf("%2d ", arr[k]); }
}

//--------------------------------------------------------------------
//  処理過程の表示
//--------------------------------------------------------------------

void proc_view(Data arr[], int n, int ct_c, int ct_s) 
{
  printf(" %3d   %3d :  ", ct_c, ct_s);
  output_arr(arr, n); puts("");
}
