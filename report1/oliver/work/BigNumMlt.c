//====================================================================
//  工学部「情報環境実験１」(富永)  例題
//  多倍長整数の計算  四則演算の関数実装
//--------------------------------------------------------------------
//  BigNum  BigNumLib.c
//  ライブラリ
//  Linux  GCC 4.4
//--------------------------------------------------------------------
//  富永研究室  tominaga 富永浩之
//  2017.05.06  v3.0
//--------------------------------------------------------------------
//  s16t255 西村紫竜
//  2017.05.06  v3.0  元ソース
//====================================================================


//====================================================================
//  前処理
//====================================================================

//--------------------------------------------------------------------
//  ヘッダ指定
//--------------------------------------------------------------------

#include <stdio.h>
#include "BigNumLib.h"


//====================================================================
//  関数定義  乗算
//====================================================================

//--------------------------------------------------------------------
//  多倍長整数の多倍長整数による乗算 (畳込法による)
//--------------------------------------------------------------------

Bool bignum_mlt(BigNum b1, BigNum b2, BigNum *b0) 
{
    //----  局所宣言
    int k1, k2;    // 反復変数

    //----  事前処理
    if ( b1.nsz + b2.nsz > UNI ) { return FALSE; }    // 計算範囲の吟味
    bignum_init(b0, 0, 0);                            // 計算結果の初期化

    //----  畳込による計算処理
    for ( k1 = 0; k1 < b1.nsz; k1++ ) { 
        for ( k2 = 0; k2 < b2.nsz; k2++ ) { 
            b0->node[k1+k2] += b1.node[k1] * b2.node[k2];    // 節同士の乗算と加算
            b0->cnt++;
        }
    }

    //----  事後処理
    return bignum_normal(b0);    // 結果の吟味と正規化
}

//--------------------------------------------------------------------
//  節長打切の多倍長整数の乗算 (畳込法による)
//--------------------------------------------------------------------

Bool bignum_mod(BigNum b1, BigNum b2, int p, BigNum *b0) 
{
    //----  局所宣言
    int k1, k2;    // 反復変数

    //----  事前処理
    bignum_init(b0, 0, 0);                            // 計算結果の初期化

    //----  畳込による計算処理
    for ( k1 = 0; k1 < b1.nsz; k1++ ) { 
        for ( k2 = 0; k2 < b2.nsz; k2++ ) { 
            if ( k1+k2 >= p ) { continue; }
            b0->node[k1+k2] += b1.node[k1] * b2.node[k2];    // 節同士の乗算と加算
        }
    }

    //----  事後処理
    return bignum_normal(b0);    // 結果の吟味と正規化
}

//--------------------------------------------------------------------
//  多倍長整数の倍分 (多倍長整数への単倍長整数の乗算更新)
//--------------------------------------------------------------------

Bool bignum_scl(BigNum *b0, int a) 
{
    int k;
    for ( k = 0; k < b0->nsz; k++ ) { b0->node[k] *= a; }    // スカラー倍    
    return bignum_normal(b0);    // 結果の吟味と正規化
}


//====================================================================
//  関数定義  累乗
//====================================================================

//--------------------------------------------------------------------
//  多倍長整数の累乗
//--------------------------------------------------------------------

Bool bignum_pow(BigNum b1, int e, BigNum *b0) 
{
    // return bignum_pow1(b1, e, b0);    // 素朴法による実装
    return bignum_pow2(b1, e, b0);    // 二乗法による実装
}

//--------------------------------------------------------------------
//  素朴法による多倍長整数の累乗
//--------------------------------------------------------------------

Bool bignum_pow1(BigNum b1, int e, BigNum *b0) 
{
    //----  初期処理
    bignum_init(b0, 1, 0);    // 結果*b0を1に初期化

    //----  素朴法の計算処理
    while ( e > 0 ) {
        if ( bignum_mlt(*b0, b1, b0) ) { e--; continue; }
        return FALSE;
    }
    return TRUE;    // 正常に処理完了
}

//--------------------------------------------------------------------
//  二乗法による多倍長整数の累乗
//--------------------------------------------------------------------

Bool bignum_pow2(BigNum b1, int e, BigNum *b0) 
{
    //----  初期処理
    bignum_init(b0, 1, 0);    // 結果*b0を1に初期化

    //----  二分法による累乗計算
    while ( e > 0 ) {
        if ( e%2 == 0 ) {    // 指数eの奇偶で場合分け
            if ( bignum_sq(&b1) ) { e /= 2; } else { return FALSE; }
        } else { 
            if ( bignum_mlt(*b0, b1, b0) ) { e--; } else { return FALSE; }
        }
    }
    return TRUE;    // 正常に処理完了
    // 計算処理は簡単だが，範囲超過の判定が必要
}

Bool bignum_pow3(BigNum b1, int e, BigNum *b0) 
{
    //----  初期処理
    bignum_init(b0, 1, 0);    // 結果*b0を1に初期化

    //----  二分法による累乗計算
    while ( e > 0 ) {
        if ( e%2 == 0 ) {    // 指数eの奇偶で場合分け
            if ( bignum_sq_k(&b1) ) { e /= 2; } else { return FALSE; }
        } else { 
            if ( bignum_mlt(*b0, b1, b0) ) { e--; } else { return FALSE; }
        }
    }
    return TRUE;    // 正常に処理完了
    // 計算処理は簡単だが，範囲超過の判定が必要
}

//--------------------------------------------------------------------
//  多倍長整数の二乗更新
//--------------------------------------------------------------------

Bool bignum_sq(BigNum *b)
{
   int s = 1;
   if ( b->nsz * 2 > UNI ) { return FALSE; }    // 桁溢れ
   //----  通常の二乗
   return bignum_sq1(b);
   //----  カラツバ法
   while ( s < b->nsz ) { s *= 2; }    // 有効な節長を2の累乗に制限
   //return bignum_sq2(b, s);
}

Bool bignum_sq_k(BigNum *b)
{
   int s = 1;
   if ( b->nsz * 2 > UNI ) { return FALSE; }    // 桁溢れ
   //----  カラツバ法
   while ( s < b->nsz ) { s *= 2; }    // 有効な節長を2の累乗に制限
   return bignum_sq2(b, s);
}

//--------------------------------------------------------------------
//  多倍長整数の二乗 (普通に乗算)
//--------------------------------------------------------------------

Bool bignum_sq1(BigNum *b0)
{
    return bignum_mlt(*b0, *b0, b0);
}

//--------------------------------------------------------------------
//  節指定の多倍長整数の二乗 (カラツバ法)
//--------------------------------------------------------------------

Bool bignum_sq2(BigNum *b0, int s)
{
    //----  局所宣言
    BigNum c1, c2, c0;

    //----  初期処理(単倍長整数の二乗)
    if ( s == 1 ) { 
        b0->node[0] *= b0->node[0];
        return bignum_normal(b0);
    }

    //----  部分節への分解
    s /= 2;                           
    bignum_copy(*b0, 0,   s, &c1);    // 下位節
    bignum_copy(*b0, s, 2*s, &c2);    // 上位節
    bignum_add(c1, c2, &c0);          // 中位節
    // 再帰呼出をするので、sが2の累乗でないと正常に動作しない

    //--  下位節の二乗の計算
    bignum_sq2(&c1, s);            // 下位節の二乗

    //--  上位節の二乗の計算
    if ( bignum_zero(c2) ) { 
        *b0 = c1; return TRUE;       // 上位節の計算の省略
    }
    bignum_sq2(&c2, s);            // 上位節の二乗

    //--  中位節の二乗の計算
    if ( c0.nsz <= s ) { 
        bignum_sq2(&c0, s);          // 中位節の二乗
    } else { bignum_sq1(&c0); }    // 中位節の二乗(繰上りがあるため)
  
    //--  中位節への減算
    bignum_sub(c0, c1, &c0);    // 中位節から下位節の減算
    bignum_sub(c0, c2, &c0);    // 中位節から上位節の減算

    //--  部分節の移動
    bignum_shift(&c0,   s);    // 中位節の移動
    bignum_shift(&c2, 2*s);    // 上位節の移動

    //--  部分節の加算
    bignum_add(c1, c2, b0);    // 上位節と下位節の加算
    bignum_add(c0, *b0, b0);   // 中位節の加算

    //----  事後処理
    return TRUE;               // 正常に処理完了
}

//--------------------------------------------------------------------
//  多倍長整数の部分複写 (節の指定位置から指定節数の部分)
//--------------------------------------------------------------------

Bool bignum_copy(BigNum b1, int p, int u, BigNum *b0)
{
    //----  局所宣言
    int k;    // 反復変数

    //----  初期化
    bignum_init(b0, 0, 0);

    //----  事前処理
    if ( p + u > UNI ) { return FALSE; }    // 桁溢れの吟味

    //----  計算処理
    for ( k = 0; k < u; k++ ) {        // 指定節数uの間
        b0->node[k] = b1.node[p+k];    // 指定位置p以降から複写
    }

    //----  事後処理
    return bignum_normal(b0);    // 節数と桁数の格納
}

