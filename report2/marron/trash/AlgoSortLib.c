//====================================================================
//  C言語 中級プログラミング  例題
//  高速整列算法  関数ライブラリ
//--------------------------------------------------------------------
//  AlgoSort AlgoSortLib.c
//  ソース本体
//  Linux  GCC 4.4
//--------------------------------------------------------------------
//  富永研究室  tominaga 富永浩之
//  2015.05.18
//====================================================================


/*====================================================================
//  仕様
//====================================================================

5種類の高速整列算法を実装する。

シェルソート    shell_sort()  間隔を置いた事前処理の後に本処理(挿入法)
コームソート    comb_sort()   間隔を置いた事前処理の後に本処理(交換法)
マージソート    merge_sort()  再帰呼出の中で併合処理(挿入法の改良)
クイックソート  quick_sort()  振分処理の後で再帰呼出(交換法の改良)
ヒープソート    heap_sort()   ヒープ木の生成と取出(選択法の改良)

--------------------------------------------------------------------*/


//====================================================================
//  ヘッダ情報
//====================================================================

#include <stdio.h>
#include <stdlib.h>
#include "AlgoSortLib.h"


//====================================================================
//  シェルソート
//====================================================================

//--------------------------------------------------------------------
//  シェルソートの本体
//--------------------------------------------------------------------

void shell_sort(Data arr[], int n) 
{
  int cnt = 3;    // 間隔列の係数(拡大率)
  int gap = 1;    // 間隔の初期値
  int p;

  //----  間隔列の逆算
  while ( gap < (n/2) ) {    // 間隔の始値の範囲の制限
   gap *= cnt; gap++;               // 間隔の更新
  }

  //----  シェルソートの本体
  while ( gap > 0 ) {
    gap /= cnt;    // 間隔の更新
    //----  シェルソートの各ラン(指定間隔での挿入法)
    for ( p = 0; p < gap; p++ ) {    
      shell_sort_run(arr, p, n, gap);    // 指定間隔での挿入法の呼出
    }
  }
}

//--------------------------------------------------------------------
//  シェルソートの各ラン(挿入法)
//--------------------------------------------------------------------

void shell_sort_run(Data arr[], int low, int hig, int gap) 
{
  int i, j;
  for ( i = low; i < hig-gap; i += gap ) {
    for ( j = i; j >= low; j -= gap ) {
      if ( arr_order(arr, j, j+gap) ) { break; }    // 正順なら打切
      arr_swap(arr, j, j+gap);                      // 逆順なら交換
    }
  }
}

/*--------------------------------------------------------------------
間隔列の拡大率 cnt には、2 または 3 が使われる。
間隔列の隣接する値は、互いに素となるようにする方がよい。
そのために、間隔の漸化式には +1 を付ける。
性能評価では、拡大率 cnt を実数型とし、2.0〜3.0 の範囲で調べる
--------------------------------------------------------------------*/


//====================================================================
//  コームソート
//====================================================================

//--------------------------------------------------------------------
//  コームソートの本体
//--------------------------------------------------------------------
void comb_sort(int arr[], int n) 
{
  double cnt = 1.3;    // 間隔列の収縮係数
  int gap = n;         // 間隔の最大値
  Bool flag = TRUE;    // 交換の有無
  int k;

  //----  コームソートの本体
  while ( gap > 1 || flag == TRUE ) {
    //--  事前処理
    flag = FALSE;    // 交換無に初期化
    gap /= cnt;      // 間隔の更新(整数型へのキャスト)
    //--  間隔の調整
    if ( gap == 0 ) { gap = 1; }                  // 間隔1は必須
    if ( gap == 9 || gap == 10 ) { gap = 11; }    // 経験的な調整
    //--  コームソートの各ラン(指定間隔での単純交換法)
    for ( k = 0; k < n - gap; k++ ) {
      if ( ! arr_ord(arr, k, k+gap) ) { 
        arr_swap(arr, k, k+gap); 
        flag = TRUE; 
      } 
    }
  }
}

/*--------------------------------------------------------------------
交換の有無の記録が重要である。これを用いて、整列済のときの打切を行う。
この打切りがないと効率化にならない。
コームソートでは、11 8 6 4 3 2 1 という間隔列が、
9 6 4 3 2 1 および 10 7 5 3 2 1 より効率が良いことが知られている。
比較回数はいったん増える可能性があるが、後の処理の減少に繋がる。
収縮率を変更して調べるときは、この間隔の調整を行わない。
間隔の収縮を整数計算で済ますには、gap *= 10; gap /= 13; とする。
--------------------------------------------------------------------*/


//====================================================================
//  クイックソート
//====================================================================

//--------------------------------------------------------------------
//  クイックソートの本体
//--------------------------------------------------------------------

void quick_sort(Data arr[], int n) 
{
  quick_sort_rec(arr, 0, n-1);    // 本体の再帰呼出
}

//--------------------------------------------------------------------
//  クイックソートの再帰処理
//--------------------------------------------------------------------

void quick_sort_rec(Data arr[], int low, int hig) 
{
  //----  局所変数
  int thre = 20;    // 挿入法への切替のデータ数
  int i = low;      // 左端
  int j = hig;      // 右端
  //----  基準値の決定
  // int k = (low+hig)/2;                 // 中央位置
  Data piv = (arr[low]+arr[hig])/2;    // 両端位置の要素の平均による基準値
  // Data piv = arr[0];                   // 先頭位置の要素による基準値
  // Data piv = arr[k];                   // 中央位置の要素による基準値
  //----  再帰終了
  if ( low  >= hig ) { return; }
  //----  挿入法に切替え
  if ( hig-low < thre ) { ins_sort_sub(arr, low, hig); }
  //----  振分処理
  while ( i <= j ) {                   // ループ内ではlow≦i≦j≦higが成立
    while ( arr[i] < piv ) { i++; }    // 左側で基準値以上の要素
    while ( arr[j] > piv ) { j--; }    // 右側で基準値以下の要素
    if ( i > j ) { break; }            // 走査の完了
    arr_swap(arr, i, j);               // 要素の交換
    i++; j--;                          // 位置の更新
  } 
  //----  再帰呼出(ループ終了時にはj＜iが成立)
  if ( low < j ) { quick_sort_rec(arr, low, j); }  // 左部分列(小の組)
  if ( hig > i ) { quick_sort_rec(arr, i, hig); }  // 右部分列(大の組)
}

//--------------------------------------------------------------------
//  部分列への単純挿入法
//--------------------------------------------------------------------

void insert_sort_sub(Data arr[], int low, int hig) 
{
  int i, j;
  for ( i = low; i < hig; i++ ) {
    for ( j = i; j >= low; j-- ) {
      if ( arr_order(arr, j, j+1) ) { break; } 
      arr_swap(arr, j, j+1);
    }
  }
}

/*--------------------------------------------------------------------
クイックソートでは、基準値が偏ると非効率である。整列している場合に
非効率にならないようにするため、最初と最後の平均値を選んでおく。
データ数が20以下になると、単純挿入法に切り替えた方が効率が良い。
--------------------------------------------------------------------*/


//====================================================================
//  マージソート
//====================================================================

//--------------------------------------------------------------------
//  マージソートの本体
//--------------------------------------------------------------------

void merge_sort(Data arr[], int n) 
{
  Data *tmp = (Data *) malloc(sizeof(Data) * (n+1)/2);    // 一時配列の領域確保
  merge_sort_rec(arr, 0, n-1, tmp);                       // 本体の再帰呼出
}

//--------------------------------------------------------------------
//  マージソートの再帰処理
//--------------------------------------------------------------------

void merge_sort_rec(Data arr[], int low, int hig, Data tmp[]) 
{
  int i = 0;
  int j = (low+hig)/2;    // 中央位置
  int k;
  //----  再帰終了
  if ( low >= hig ) { return; }
  //----  再帰呼出
  merge_sort_rec(arr, low, j, tmp); j++;    // 左部分列
  merge_sort_rec(arr, j, hig, tmp);         // 右部分列
  //----  事前処理(左部分列の一時配列のコピー)
  for ( k = low; k < j; k++ ) { tmp[k-low] = arr[k]; }
  //----  併合処理
  for ( k = low; k < j; k++ ) {
    if ( j > hig || tmp[i] <= arr[j] ) { 
      arr[k] = tmp[i]; i++;    // 左部分列からの要素コピー
    } else { 
      arr[k] = arr[j]; j++;    // 右部分列からの要素コピー
    }
  }
}

/*--------------------------------------------------------------------
マージソートでは、データ数が2の巾乗のときが、実装も簡単で、効率的である。
一般のデータ数では、不揃いの部分の処理が面倒である。
--------------------------------------------------------------------*/


//====================================================================
//  ヒープソート
//====================================================================

//--------------------------------------------------------------------
//  ヒープソートの本体
//--------------------------------------------------------------------

void heap_sort(Data arr[], int n) 
{
  int k;
  //----  ヒープ木への変換
  for ( k = n/2; k >= 0; k-- ) {    // 子節を持つ節を右側から走査
    heap_sort_run(arr, k, n-1);     // ヒープ木の篩落し
  }
  //----  ヒープ木からの整列
  for ( k = n-1; k > 0; k-- ) {     // 右側から整列部分を増やしていく
    arr_swap(arr, 0, k);            // 最大要素を整列済の部分列に移動
    heap_sort_run(arr, 0, k-1);     // ヒープ木の篩落し
  }
}

/*--------------------------------------------------------------------
篩落しには、再帰法、反復法のどちらを用いてもよい。
比較と交換の回数は変わらない。
反復法の方が、再帰呼出の負荷がないので、より高速である。
--------------------------------------------------------------------*/

//--------------------------------------------------------------------
//  ヒープ木の篩落し(再帰法)
//--------------------------------------------------------------------

void heap_sort_rec(Data arr[], int up, int lst) 
{
  int ch = 2*up+1;    // 左の子節の位置
  //----  再帰終了
  if ( ch > lst ) { return; }
  //----  子節同士の比較
  if ( ch+1 <= lst ) {                      // 右の子節があるとき
    if ( arr[ch] < arr[ch+1] ) { ch++; }    // 子節同士の比較
  }
  //----  親節と子節の比較
  if ( arr[up] < arr[ch] ) {        // 親節と子節の比較
    arr_swap(arr, up, ch);          // 親節と子節の交換
    heap_sort_rec(arr, ch, lst);    // 子節を根節とする再帰呼出
  }
}

//--------------------------------------------------------------------
//  ヒープ木の篩落し(反復法)
//--------------------------------------------------------------------

void heap_sort_run(Data arr[], int up, int lst) 
{
  int ch = 2*up+1;         // 左の子節の位置
  while ( ch <= lst ) {    // 子節が存在する間
    //----  子節同士の比較
    if ( ch+1 <= lst ) {                      // 右の子節があるとき
      if ( arr[ch] < arr[ch+1] ) { ch++; }    // 大きい方を選ぶ
    }
    //----  親節と子節の比較
    if ( arr[up] < arr[ch] ) {
      arr_swap(arr, up, ch);    // 親節と子節の交換 
      up = ch;                  // 子節を新しい親節とする
      ch = 2*up+1;              // 新しい親節の左の子節
    } else {
      break;                    // 篩落しの終了
    }
  }
}


//====================================================================
//  補助関数
//====================================================================

//--------------------------------------------------------------------
//  配列の要素の比較
//--------------------------------------------------------------------

Bool arr_order(Data arr[], int p1, int p2) 
{
  if ( arr[p1] <= arr[p2] ) { return TRUE; } 
    else { return FALSE; }
}

//--------------------------------------------------------------------
//  配列の要素の交換
//--------------------------------------------------------------------

void arr_swap(Data arr[], int p1, int p2) {
  Data tmp;
  tmp = arr[p1]; arr[p1] = arr[p2]; arr[p2] = tmp;
}


//====================================================================
//  データの入出力
//====================================================================

//--------------------------------------------------------------------
//  配列への入力
//--------------------------------------------------------------------

void input_arr(Data arr[], int n) 
{
  int k;
  for ( k = 0; k < n; k++ ) { scanf("%d", &arr[k]); }
}

//--------------------------------------------------------------------
//  配列からの出力
//--------------------------------------------------------------------

void output_arr(Data arr[], int n) 
{
  int k;
  for ( k = 0; k < n; k++ ) { printf("%2d ", arr[k]); }
}
